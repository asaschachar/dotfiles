"-------------------------------------------------------------------------------
" NeoBundle
"-------------------------------------------------------------------------------

" Note: Skip initialization for vim-tiny or vim-small.
if !1 | finish | endif

if has('vim_starting')
  if &compatible
    set nocompatible               " Be iMproved
  endif

  " Required:
  set runtimepath+=~/.vim/bundle/neobundle.vim/
endif

" Required:
call neobundle#begin(expand('~/.vim/bundle/'))

" Let NeoBundle manage NeoBundle
" Required:
NeoBundleFetch 'Shougo/neobundle.vim'

source ~/.vim.bundles.vim

call neobundle#end()

" Required:
filetype plugin indent on

" If there are uninstalled bundles found on startup,
" this will conveniently prompt you to install them.
NeoBundleCheck

"-------------------------------------------------------------------------------
" Basics
"-------------------------------------------------------------------------------

syntax on
set background=dark

if filereadable(expand("~/.vim/bundle/vim-colors-solarized/colors/solarized.vim"))
  let g:solarized_termcolors=256
  let g:solarized_termtrans=1
  let g:solarized_contrast="normal"
  let g:solarized_visibility="normal"
  color solarized
endif

" Use <Leader> in global plugin.
let g:mapleader = ','
" Use <LocalLeader> in filetype plugin.
let g:maplocalleader = 'm'

set textwidth=80
set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab
set rnu
set nobackup
set nowritebackup
set noswapfile
set mouse=a
set list
set listchars=""                " Reset the listchars
set listchars=tab:\ \           " a tab should display as "  ", trailing whitespace as "."
set listchars+=trail:.          " show trailing spaces as dots
set listchars+=extends:>        " The character to show in the last column when wrap is
                                " off and the line continues beyond the right of the screen
set listchars+=precedes:<       " The character to show in the last column when wrap is
                                " off and the line continues beyond the right of the screen
set autoread                    " Automatically read
set cursorline                  " Highlight current line
set backspace=indent,eol,start  " Backspace for dummies
set linespace=0                 " No extra spaces between rows
set number                      " Line numbers on
set showmatch                   " Show matching brackets/parenthesis
set incsearch                   " Find as you type search
set hlsearch                    " Highlight search terms
set winminheight=0              " Windows can be 0 line high
set ignorecase                  " Case insensitive search
set smartcase                   " Case sensitive when uc present
set wildmenu                    " Show list instead of just completing
set wildmode=list:longest,full  " Command <Tab> completion, list matches, then longest common part, then all.
set whichwrap=b,s,h,l,<,>,[,]   " Backspace and cursor keys wrap too
set scrolljump=5                " Lines to scroll when cursor leaves screen
set scrolloff=3                 " Minimum lines to keep above and below cursor
set nofoldenable                " Disable auto fold code
set nojoinspaces                " Prevents inserting two spaces after punctuation on a join (J)
set splitright                  " Puts new vsplit windows to the right of the current
set splitbelow                  " Puts new split windows to the bottom of the current
set pastetoggle=<F12>           " pastetoggle (sane indentation on pastes)
set colorcolumn=+1              " Highlight 81st column
" Highlight when CursorMoved.
set cpoptions-=m
set matchtime=1

" FileType specific

"" {{{ Clojure
augroup ft_clojure
  "" testing
  au FileType clojure setlocal lispwords+=describe,it,testing,facts,fact,provided
  "" jdbc
  au FileType clojure setlocal lispwords+=with-connection,with-query-results,with-naming-strategy,with-quoted-identifiers,update-or-insert-values,insert-record,delete-rows,insert!
  "" core.async
  au FileType clojure setlocal lispwords+=go-loop
  "" carmine (redis)
  au FileType clojure setlocal lispwords+=wcar
  "" ClojureScript
  au FileType clojure setlocal lispwords+=this-as

  " Indent top-level form.
  au FileType clojure nmap <buffer> <localleader>= mz99[(v%='z

  "" TODO: visual bindings
  au Filetype clojure nnoremap <localleader>ee :Eval<CR>
  au Filetype clojure nnoremap <localleader>ef :%Eval<CR>
  au Filetype clojure nnoremap <localleader>er :Require<CR>
  au Filetype clojure nnoremap <localleader>eR :Require!<CR>
  au Filetype clojure nnoremap <localleader>r :call fireplace#eval("(user/reset)")<CR>
augroup END

augroup prismatic
  au FileType clojure setlocal lispwords+=fnk,defnk,for-map,letk
  au FileType clojure setlocal lispwords+=go-loop
  au FileType clojure setlocal lispwords+=this-as

  let g:clojure_align_subforms = 1
  let g:clojure_align_multiline_strings = 1
  let g:clojure_special_indent_words = 'deftype,defrecord,defprotocol,reify,proxy,extend-type,extend-protocol,letfn,implement,specify,specify!,' .
        \ 'defcomponent,defcomponentk,defcomponentmethod,defmixin'

  autocmd BufNewFile,BufReadPost *.cljx setfiletype clojure
augroup END

"" EDN
au BufRead,BufNewFile *.edn setfiletype clojure

"-------------------------------------------------------------------------------
" Abbreviations
"-------------------------------------------------------------------------------
iabbrev ldis ಠ_ಠ
iabbrev lsad ಥ_ಥ
iabbrev lhap ಥ‿ಥ
iabbrev lmis ಠ‿ಠ

"-------------------------------------------------------------------------------
" Mappings
"-------------------------------------------------------------------------------
"
" Wrapped lines goes down/up to next row, rather than next line in file.
noremap j gj
noremap k gk

" Disable Ex mode
map Q <Nop>

" Some helpers to edit mode
" http://vimcasts.org/e/14
cnoremap %% <C-R>=expand('%:h').'/'<cr>
map <leader>ew :e %%
map <leader>es :sp %%
map <leader>ev :vsp %%
map <leader>et :tabe %%
noremap <Leader>dt :tabnew<Enter><Leader>d

" Last tab binding
let g:lasttab = 1
nmap <c-w>; :exe "tabn ".g:lasttab<cr>
au TabLeave * let g:lasttab = tabpagenr()

" Safely alias :we to :w
cnoreabbrev <expr> we ((getcmdtype() is# ':' && getcmdline() is# 'w')?('we'):('w'))

" Don't move on *
nnoremap * *<c-o>

" Keep search matches in the middle of the window.
nnoremap n nzzzv
nnoremap N Nzzzv

" Tab close
nnoremap <Leader>C :tabc<CR>

" Yank from the cursor to the end of the line, to be consistent with C and D.
nnoremap Y y$

"-------------------------------------------------------------------------------
" Plugin Settings
"-------------------------------------------------------------------------------

" kein/rainbow_parens.vim
au VimEnter * RainbowParenthesesToggle
au Syntax * RainbowParenthesesLoadRound
au Syntax * RainbowParenthesesLoadSquare
au Syntax * RainbowParenthesesLoadBraces
"  Parentheses colours using Solarized"
let g:rbpt_colorpairs = [
  \ [ '13', '#6c71c4'],
  \ [ '5',  '#d33682'],
  \ [ '1',  '#dc322f'],
  \ [ '9',  '#cb4b16'],
  \ [ '3',  '#b58900'],
  \ [ '2',  '#859900'],
  \ [ '6',  '#2aa198'],
  \ [ '4',  '#268bd2'],
  \ ]

" jslint
let $JS_CMD='node'

" airline
let g:airline_powerline_fonts = 1
let g:airline#extensions#tabline#enabled = 1

" CtrlP
let g:ctrlp_switch_buffer = 0
let g:ctrlp_user_command = {
    \ 'types': {
      \ 1: ['.git', 'cd %s && git ls-files'],
      \ 2: ['.hg', 'hg --cwd %s locate -I .'],
      \ },
    \ 'fallback': 'find %s -type f'
  \ }

 let g:ctrlp_custom_ignore = {
       \ 'file': '\.exe$\|\.so$\|\.dll$\|\.pyc$',
       \ 'dir': '\.git$\|\.hg$\|\.svn$\|\.repl'
       \ }

" Ack
nnoremap <leader>a :Ack!<space>
let g:ackprg = 'ag --nogroup --nocolor --column'

" Tagbar
"" Move focus to tagbar when it opens to make it usable for windows on right side
let g:tagbar_autofocus = 1

" Tabularize
nmap <Leader>a- :Tabularize /=><CR>
vmap <Leader>a- :Tabularize /=><CR>

" vim-indent-guides
let g:indent_guides_enable_on_vim_startup = 0

" vim-gitgutter
let g:gitgutter_eager = 0

"-------------------------------------------------------------------------------
" General Settings & Modifications
"-------------------------------------------------------------------------------

" Use clipboard register.
if has('unnamedplus')
  set clipboard& clipboard+=unnamedplus
else
  set clipboard& clipboard+=unnamed
endif

" Disable session dialog
let g:session_autosave='no'

" Tabline modifications
if has('gui')
  set guioptions-=e
endif
if exists("+showtabline")
  function! MyTabLine()
    let s = ''
    let t = tabpagenr()
    let i = 1
    while i <= tabpagenr('$')
      let buflist = tabpagebuflist(i)
      let winnr = tabpagewinnr(i)
      let s .= '%' . i . 'T'
      let s .= (i == t ? '%1*' : '%2*')
      let s .= ' '
      let s .= i . ':'
      let s .= winnr . '/' . tabpagewinnr(i,'$')
      let s .= ' %*'
      let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')
      let bufnr = buflist[winnr - 1]
      let file = bufname(bufnr)
      let buftype = getbufvar(bufnr, 'buftype')
      if buftype == 'nofile'
        if file =~ '\/.'
          let file = substitute(file, '.*\/\ze.', '', '')
        endif
      else
        let file = fnamemodify(file, ':p:t')
      endif
      if file == ''
        let file = '[No Name]'
      endif
      let s .= file
      let i = i + 1
    endwhile
    let s .= '%T%#TabLineFill#%='
    let s .= (tabpagenr('$') > 1 ? '%999XX' : 'X')
    return s
  endfunction
  set stal=2
  set tabline=%!MyTabLine()
endif

"{{{ TAB MGMT
" Source: https://raw.githubusercontent.com/lucasoman/Conf/master/.vimrc
" Some useful bits for managing tabs.
" Also changes format of tab line.
" Commands and shortcuts:
" \oc - open dir of current file in new tab
" H - navigate to tab to the left
" L - navigate to tab to the right
" C-l - move current tab left
" C-h - move current tab right
" gf - changes default behavior from opening file under cursor in current window to opening in new tab
nmap <Leader>oc :tabe %:h<CR>

" quicker aliases for navigating tabs
nmap H gT
nmap L gt
" move tab left or right
nmap <C-l> :call MoveTab(0)<CR>
nmap <C-h> :call MoveTab(-2)<CR>

" gf should use new tab, not current buffer
map gf :tabe <cfile><CR>

"tab line
fun! MyTabLine()
  let s = ''
  for i in range(tabpagenr('$'))
    " select the highlighting
    if i + 1 == tabpagenr()
      let s .= '%#TabLineSel#'
    else
      let s .= '%#TabLine#'
    endif
    " set the tab page number (for mouse clicks)
    let s .= '%' . (i + 1) . 'T'.(i+1).''
    " the filename is made by MyTabLabel()
    let s .= '%{MyTabLabel(' . (i + 1) . ')}  '
  endfor
  " after the last tab fill with TabLineFill and reset tab page nr
  let s .= '%#TabLineFill#%T'
  return s
endfunction

fun! MyTabLabel(n)
  let buflist = tabpagebuflist(a:n)
  let winnr = tabpagewinnr(a:n)
  let fullname = bufname(buflist[winnr - 1])
  " show a/b/c/filename.ext
  "let fullname = substitute(fullname,"(\w){1}\w*/","\1/","g")
  " show filename.ext
  let fullname = substitute(fullname,".*/","","")
  if getbufvar(buflist[winnr - 1],"&mod")
    let modified = "+"
  else
    let modified = " "
  endif
  return modified.fullname
endfunction

" Use the above tabe naming scheme
set tabline=%!MyTabLine()

"tab moving
fun! MoveTab(n)
  let which = tabpagenr()
  let which = which + a:n
  exe "tabm ".which
endfunction
"}}}
